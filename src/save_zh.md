# 保存工具
本页讨论了诸多可以显著提升保存及加载文件效率的数值工具，均以科学计算为背景。

这些工具也应用在[现实案例](@ref)中展示的案例中。在阅读完本页文档之后，推荐您阅读那一章节的内容！ 

在DrWatson里我们用函数 `wsave(filename, data)` 和 `wload(filename)` 来保存和读取文件。 这些函数将在下文中被进一步使用，例如 [`tagsave`](@ref)。这些函数也可以根据您自己特殊的数据类型进行改写。

此外， `wsave` **确保** 始终在您尝试保存文件的路径上调用`mkpath` 。 我们都体会过运行两小时模拟之后数据没有保存的痛苦，而这仅仅是因为 `FileIO.save` 因为找不到路径而报错。

要改写保存的数据类型，请为`DrWatson._wsave(filename, ::YourType, args...; kwargs...)`（注意函数名后有下划线`_`！）添加新方法。通过覆盖载入`_wsave`，您可以为自定义的数据类型获得 [`tagsave`](@ref), [`safesave`](@ref)等所提供的所有额外功能（`tagsave`要求您以字典形式保存数据，或者为自己的类型扩展 [`tag!`](@ref)）。

!!! warning "加载与保存的回退机制"
    默认情况下，对于任意的文件类型，我们都会回退至 `FileIO.save` 与 `FileIO.load`。
    这意味着，您必须安装自己想要使用的存档后端。
    `FileIO`自身并 _不会_ 安装存储数据的程序包，它只提供接口！
    文件的 *后缀* 决定了应该使用哪个包来保存文件。须知保存文件包的工作原理以及接受的输入类型这也是 **您自身的责任** ！

## 安全地保存数据
几乎所有的保存数据的程序包默认覆写已经存在的文件（如果您给定一个已有的文件名）。 因为有此类需求，所以我们将其设为了程序默认。

但有时候并不是这样！ 覆写数据的后果可能是无关紧要的，也可能是灾难性的。 为了避免类似情形的发生，我们提供了一种可选的方法来保存数据，这种方法永远不会覆写已经存在的文件，即：
```@docs
safesave
```

## 用Git来标记运行的程序
考虑到程序需要能够被复现， 同时避免不会因为 “我怎么才能复现这个结果”而抓狂，用储存库的Git状态来标记任何的模拟/结果/进程将变得十分有用。

为此我们有一些函数来保证模拟结果的可复现性。

```@docs
tagsave
@tagsave
```
函数同样包含[`safesave`](@ref)选项, 如果需要的话。

### 底层函数
[`@tagsave`](@ref) 函数内置了以下底层函数:
```@docs
tag!
@tag!
gitdescribe
DrWatson.gitpatch
isdirty
```

请注意, `tag!` 仅会在可能的情形下进行内存的原地操作。 如果不可能，函数将会返回一个新的字典。 同样需要注意，由于这些函数通常在保存模拟数据时使用，这些函数将**永远不会报错**，这会导致数据未被保存。

## 生成或加载
`produce_or_load` 是一个高度集成 [`savename`](@ref) 的函数，可以根据文件是否存在来加载文件。若文件不存在，则生成、保存并返回它的值！

这节省了您检查文件是否存在，再加载，或者再运行某些代码并保存它的麻烦，或者在代码中编写一堆`if`语句的工作量。
此外，它试图尽量减小获取模拟结果所花费的算力。
```@docs
produce_or_load
@produce_or_load
istaggable
```

请参见[不再有“我到底有没有跑过这个模拟”的焦虑](@ref)中使用 `produce_or_load` 的示例。虽然 `produce_or_load` 默认情况下会尝试标记您的数据（如果可能的话），但您也可以将其与其他格式一起使用。例如，当您的模拟函数 `f` 返回一个 `DataFrame` 且文件后缀为 "csv" 时，标记功能将不会工作，但 `produce_or_load` 函数 将按预期生效。

## 将结构体转换为字典
[`savename`](@ref) 能够很好地支持从任何 Julia 复合类型中获取名称。但是需要一个字典来保存某些东西。因此，以下函数可以直接用于保存结构体：
```@docs
struct2dict
struct2ntuple
```
