# 运行模拟 & 列出模拟

## 模拟前的准备工作

通常情况下，您会希望以批处理的方式批量进行数值模拟，即仅使用相同的算法和代码提交一堆参数不同的模拟。这种情况始终要求用户准备一组模拟参数容器，然后将其传递到某种类型的“主”函数中以启动模拟。

为了简化准备工作，我们提供了以下函数：
```@docs
dict_list
dict_list_count
@onlyif
Derived
```

使用上述函数意味着您可以将“准备”步骤写进一个字典变量中，然后让它自动扩展为许多参数容器。这有助于保持代码的纯净与一致性，前提是它遵循这样一个简单的规则：**如果字典的键值是一个`向量`，则该向量有很多参数，否则它仅有一个参数**。函数 [`dict_list`](@ref) 将始终遵循这个规则，无论`向量`中包含的内容是什么。这允许用户使用任何可迭代的自定义类型作为模拟的单个“参数”。
详见 [模拟前的准备 & 运行模拟](@ref) 部分中非常简单的用例。

## 临时字典的保存
函数 [`dict_list`](@ref) 的功能非常强大，但对于将代码提交到计算机集群的情形可能不太够用。对于使用`qsub`或`slurm`的典型集群，每次运行都会提交到不同的Julia进程，因此无法传播Julia内存中的`Dict`变量（若您已经在连接着大量处理器/节点的机器上运行，请直接使用`pmap`即可）。

为了平衡这一点，我们在这里提供了一些简单的函数，可以将[`dict_list`](@ref)（或任何其他字典集）的结果存储到具有临时名称的文件中。这些名称将被返回，然后可以传播到类似`main`的Julia进程中，该进程可以将临时名称作为输入来加载字典，然后提取数据。
```@docs
tmpsave
```
具体例子参见[使用串行集群](@ref)页面。

## 模拟结果的收集
有时您已经将一大批模拟结果保存在文件夹中的一大批不同文件中。因此有必要能够将所有这些结果收集到单个表格中，此种情形即`DataFrame`。函数[`collect_results!`](@ref)提供了这个功能。重要的是，该函数是即时更新的，这意味着即使你在项目进展中添加新参数或删除旧参数，它也可以很好地工作！
```@docs
collect_results!
collect_results
```
此函数的用例请参见文档[现实案例](@ref)部分!